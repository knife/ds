= DS - Data Structures

DS provides some common data structures not implement in Ruby natively.

The DS supports the folowing data structures:
* Pair
* Stacks
  * Stack
* Queues
  * Queue
  * PriorityQueue
* Lists
  * List
  * CyclicList
  * Ring
* Trees
  * Tree
  * BinaryTree
  * CompleteBinaryTree
  * BinaryHeap
  * BinarySearchTree
  * Trie
* Graphs
  * Graph
  * Digraph
* Matrixes
  * Array2D
  * ExpandableArray
  * TriMatrix
* Sets
  * OrderedSet


== Instalation
  
  gem install ds


== Usage

  require 'ds'
  stack = DS::Stack.new

  # To not have to type "DS::" before each class, use:
  include DS
  stack = Stack.new

=== Pair

Creating new Pair
  p = Pair.new(1,2)

Accessors defined on Pair object:

  p.key #=> 1
  p.first #=> 1
  p.value #=> 2
  p.second #=> 2

  p.second = 2


=== Stack

Creating new Stack (implemented as Array).  
  stack = Stack.new

The following methods available on a Stack:

* push
* pop
* size
* empty?
* size

Examples:
  stack.empty? #=> true
  stack.push :first
  stack.push :second
  stack.size #=> 2
  stack.peek #=> :second
  stack.empty? #=> false
  stack.pop #=> :second
  stack.size #=> 1


=== Queues

Creating new Queue (implemented as Array).  
  q = Queue.new

Creating new Queue (implemented as List)
  q1 = Queue.create
  q1 = Queue.new(:list)

The following methods available on a Queue:

* enqueue(push)
* dequeue(shift)
* peek
* length
* empty?

Examples:
  q.enqueue :first
  q.push :second
  q.peek #=> :first
  q.length #=> 2
  q.empty? #=> false
  q.dequeue #=> :first
  q.shift #=> :second
  q.empty? #=> true


=== Priority Queue 

Creating new Priority Queue (implemented as Heap)
  
  q = PriorityQueue.new

Examples:
  q.push(:important, 3)
  q.push(:very_important, 5)
  q.push(:nevermind, 1)

  q.shift #=> :very_important
  q.peek #=> :important
  q.length #=> 2
  q.shift  #=> :important
  q.peek  #=> :nevermind


=== List

Creating new List
  l = List.new(3)
or 
  arr = [1,2,3,4]
  list = List.from_array(arr)

Examples:

Simple operation on lists
  list.length #=> 4
  list.append(5).to_a #=> [1,2,3,4,5] 
  list.prepend(0).to_a #=> [0,1,2,3,4,5]
  list.remove(list.head).to_a #=> [1,2,3,4,5]
  list.shift #=> 1

Accessing first and last element
  list.head.data #=> 2
  list.tail.data #=> 5

  list.first #=> 2
  list.last #=> 5

Other operations
  list.ziped? #=> false
  list.reverse!.to_a #=> [5,4,3,1,0]

Enumerable methods are also available
  
  list.map{ |e| e.data } #=> [1,2,3,4]
  list.inject(0){ |mem, var| mem = mem + var.data } #=> 10

=== Ring

Creating new Ring
  ring = Ring.from_array([1,2,3,4,5,6,7])

Examples:
  ring.looped? => true
  ring.cycle_size => 7
  ring.eliminate_by(2) => 1
  
=== Trees

Building Tree

  t = Tree.new(2)
  c1 = t << 5
  c2 = t << 8
  t << 9

  c1 << 4
  c1 << 10
  c3 = c2 << 3

Examples:
  t.leaf? #=> false
  c3.leaf? #=> true

  t.height #=> 3
  t.width #=> 3
  t.leaf_count #=> 4
  
  t.mirror! #=> mirrors tree
  t.levels #=> {1=>1,2=>3, 3=>3} 

Other methods
* get_leaves
* isometric

Enumerable Module is included.
  t.map{ |node| node.data } #=> [2,5,8,9,4,10,3]


=== Binary Tree

BinaryTree is sublass of Tree class.

Building tree
  bin_tree = BinaryTree.new
  [2,5,8,9,11,12,14].each{|x| @bin_tree.insert(x)} #build complete binary Tree

Accessors defined on BinaryTree object:
  bin_tree.left #=> 5
  bin_tree.right #=> 8

=== CompleteBinaryTree

CompleteBinaryTree does not inherit from Tree class! Nodes are stored
internally in array.

Creating
  cbt = CompleteBinaryTree.new(1,2,3,4,5,6,7)

Examples
  cbt.root #=> 1
  cbt.left(0) #=> 2
  cbt.right(0) #=> 3
  cbt.parent(1) #=> 0
  
  cbt.left_index(0) #=> 1
  cbt.right_index(1) #=> 4
  cpt.parent_index(1) #=> 0

=== Binary Heap

BinaryHeap inherits from CompleteBinaryTree class. Binary Heap allows very fast
access to maximum or minimum element of the tree.

Creating

Maximum Binary Heap 
  max_heap = BinaryHeap.new(9,8,4,5,11,6)
or
  max_heap = BinaryHeap.max(9,8,4,5,11,6)

Minimum Binary Heap
  min_heap = BinaryHeap.min(9,8,4,5,11,6)
or
  BinaryHeap.new(9,8,4,5,11,6){|parent,child| parent < child}

You can set heap relation by passing block to BinaryHeap constructor.


Examples
  max_heap.shift #returns max element (11)
  max_heap.to_a [9,8,6,5,4]
  max_heap.insert 15
  max_heap.shift #=> 15

  min_heap.shift #returns min element (4)


=== SearchBinaryTree

Creating
  bst = BinarySearchTree.from_array([8,1,5,2,7,6,3])

Examples
  walker = TreeWalker.new(b)
  walker.traverse(:inorder).must_equal [1,2,3,5,6,7,8]

=== Trie 
Trie allows very quick search: O(k) where k is word length.

Creating 
  trie = Trie.new
  
Examples
  trie.insert("thing",true);
  trie.find("thing")  # =>  true


=== Traversing tree 

Iterating in BFS order
  t.each{ |x| x }
Iterating in postorder  
  walker.traverse(:postorder) 
Iterating in inorder
  walker.traverse(:inorder) 
Iterating in preorder
  walker.traverse(:preorder)

=== Graph

Creating new Graph
    
  edges = []
  edges << Edge.new('Lukas','Marc')
  edges << Edge.new('Lukas','Tom')
  edges << Edge.new('Marc','Jack')
  edges << Edge.new('Tom','Marc')
  graph = Graph.create(edges)

Examples:

  graph.vertex_size #=> 4
  graph.degree("Marc") #=> 3
  graph.edge?("Marc","Tom") #=> true
  graph.edge?("Tom","Jack") #=> false
  graph.add_edges([Edge.new("Marc","Kate")])
  graph.remove("Marc","Jack")


=== Matrixes

=== Array2D

Creating
  discrete_matrix = Array2D.new(2,0)

Examples
  discrete_matrix.to_a  #=> [[0,0],[0,0]]
  discrete_matrix[3,3] #=> 0

Extends automatically like simple Array

=== ExpandableArray

  arr = ExpandableArray.new(0,0)
  arr[4]  = 1 #=> [0,0,0,0,4]

=== TriMatrix

Creating new Triangular Matrix
  tri_matrix = TriMatrix.new
  tri_matrix[0,1] = true
  tri_matrix[0,2] = true

Examples
  tri_matrix[0,1] == tri_matrix[1,0] #=> true


=== OrderedSet

Creating new Ordered Set
  set = OrderedSet.new

Examples
  set.push(:first)  #=>  0
  set.push(:second) #=> 1
  set.index(:first) #=> 0
  set.to_a #=> [:first, :second]


